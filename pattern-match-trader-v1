//+------------------------------------------------------------------+
//| PatternMatchTrader_v1.mq4 / .mq5                                 |
//| Dual-compatible MT4 / MT5 EA                                     |
//| Pattern leading, MA + RSI confirming, chart visualization        |
//| Risk management, trailing stops, logging, intraday hours         |
//+------------------------------------------------------------------+
#property strict

#ifdef __MQL5__
#include <Trade\Trade.mqh>
CTrade trade;
#endif

// --- Inputs
input int BarsPerPattern = 35;
input double SimilarityThreshold = 0.9;
input int LookAheadBars = 20;
input int Step = 5;
input int HistoryLimit = 1000;

input double RiskPerTrade = 0.01;
input double MaxDailyLoss = 0.02;
input double RiskRewardRatio = 2.0;
input double TrailingStopPercent = 0.5;

input int MA_Period = 50;
input int MA_Method = MODE_SMA;
input int MA_AppliedPrice = PRICE_CLOSE;

input int RSI_Period = 14;
input int RSI_BuyLevel = 50;
input int RSI_SellLevel = 50;

input int GmtOffset = 0;
input int StartHourEST = 8;
input int EndHourEST = 12;
input int PreCloseBufferMinutes = 5;

// --- Globals
datetime lastTradeDay = 0;
double startOfDayBalance = 0;
bool tradingLocked = false;
bool closedAtNoon = false;
double dailyProfit = 0;
int dailyTrades = 0;
datetime lastBarTime = 0;

//+------------------------------------------------------------------+
// Pattern similarity
double PatternSimilarity(const double &a[], const double &b[], int len)
{
   double sumA=0, sumB=0;
   for(int i=0;i<len;i++){ sumA+=a[i]; sumB+=b[i]; }
   double meanA=sumA/len, meanB=sumB/len;
   double num=0, denA=0, denB=0;
   for(int i=0;i<len;i++)
   {
      double da=a[i]-meanA;
      double db=b[i]-meanB;
      num+=da*db;
      denA+=da*da;
      denB+=db*db;
   }
   if(denA==0 || denB==0) return(0);
   return(num/MathSqrt(denA*denA*denB*denB + 1e-12)); // safe guard divide by zero
}

//+------------------------------------------------------------------+
// Daily reset
void ResetDailyStats()
{
   startOfDayBalance = AccountBalance();
   lastTradeDay = TimeCurrent();
   tradingLocked = false;
   closedAtNoon = false;
   dailyProfit = 0;
   dailyTrades = 0;
}

//+------------------------------------------------------------------+
// In trading window?
bool InTradingWindow()
{
   datetime now = TimeCurrent();
   int brokerHour = TimeHour(now);
   int brokerMinute = TimeMinute(now);
   int brokerWeekday = TimeDayOfWeek(now);
   int estHour = brokerHour - (GmtOffset + 5);
   if(estHour<0) estHour+=24;

   if(brokerWeekday<1 || brokerWeekday>5) return false;
   if(estHour>=StartHourEST && estHour<EndHourEST)
      if(!(estHour==EndHourEST-1 && brokerMinute>=60-PreCloseBufferMinutes)) return true;
   return false;
}

//+------------------------------------------------------------------+
// Logging trades
void LogTrade(string reason,int type,double lots,double entry,double exit,double profit)
{
   string path="PatternTrader_Log.csv";
   int fh=FileOpen(path,FILE_CSV|FILE_READ|FILE_WRITE|FILE_SHARE_READ,';');
   if(fh<1){ fh=FileOpen(path,FILE_CSV|FILE_WRITE|FILE_SHARE_READ,';');
      if(fh<1){Print("Failed to open log file!"); return;}
      FileWrite(fh,"DateTime","Reason","Type","Lots","EntryPrice","ExitPrice","Profit"); }
   FileSeek(fh,0,SEEK_END);
   string typeStr=(type==0)?"BUY":(type==1)?"SELL":"CLOSE";
   FileWrite(fh,TimeToString(TimeCurrent(),TIME_DATE|TIME_MINUTES),reason,typeStr,DoubleToString(lots,2),
             DoubleToString(entry,Digits),DoubleToString(exit,Digits),DoubleToString(profit,2));
   FileClose(fh);
   if(type==0 || type==1){ dailyTrades++; dailyProfit+=profit; }
}

//+------------------------------------------------------------------+
// Close all trades
void CloseAllTrades(string reason="Time/Drawdown Closure")
{
#ifdef __MQL4__
   for(int i=OrdersTotal()-1;i>=0;i--)
   {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES))
      {
         int type=OrderType();
         double price=(type==OP_BUY)?Bid:Ask;
         double lots=OrderLots();
         double entry=OrderOpenPrice();
         bool closed=OrderClose(OrderTicket(),lots,price,3,clrRed);
         if(closed)
         {
            double profit=(type==OP_BUY)?(price-entry)*lots*MarketInfo(Symbol(),MODE_TICKVALUE)/Point
                                        :(entry-price)*lots*MarketInfo(Symbol(),MODE_TICKVALUE)/Point;
            LogTrade(reason,type,lots,entry,price,profit);
         }
      }
   }
#else
   int total=PositionsTotal();
   for(int i=total-1;i>=0;i--)
   {
      string sym=PositionGetSymbol(i);
      if(sym==_Symbol)
      {
         ulong ticket=PositionGetTicket(i);
         double lots=PositionGetDouble(POSITION_VOLUME);
         double entry=PositionGetDouble(POSITION_PRICE_OPEN);
         int type=(int)PositionGetInteger(POSITION_TYPE);
         if(trade.PositionClose(sym))
         {
            double profit=(type==POSITION_TYPE_BUY)?(SymbolInfoDouble(_Symbol,SYMBOL_BID)-entry)*lots*SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE)
                                                 :(entry-SymbolInfoDouble(_Symbol,SYMBOL_ASK))*lots*SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
            LogTrade(reason,type,lots,entry,0,profit);
         }
      }
   }
#endif
}

//+------------------------------------------------------------------+
// Draw pattern visualization (once per new bar)
void DrawPatternVisualization(int patternDir)
{
   if(Time[0]==lastBarTime) return;
   lastBarTime=Time[0];

   for(int obj=ObjectsTotal()-1;obj>=0;obj--)
   {
      string name=ObjectName(obj);
      if(StringFind(name,"PatternLine")==0) ObjectDelete(name);
   }

   for(int i=0;i<BarsPerPattern-1;i++)
   {
      string lineName="PatternLine_"+IntegerToString(i);
      ObjectCreate(lineName,OBJ_TRENDBYANGLE,0,Time[i],Close[i],Time[i+1],Close[i+1]);
      ObjectSetInteger(0,lineName,OBJPROP_COLOR,(patternDir==1)?clrLime:clrRed);
      ObjectSetInteger(0,lineName,OBJPROP_WIDTH,2);
   }
}

//+------------------------------------------------------------------+
// Apply trailing stops
void ApplyTrailingStops()
{
#ifdef __MQL4__
   for(int i=0;i<OrdersTotal();i++)
   {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES))
      {
         int type=OrderType();
         double entry=OrderOpenPrice();
         double curSL=OrderStopLoss();
         double lots=OrderLots();
         double tsPoints=(AccountEquity()*TrailingStopPercent/100)/MarketInfo(Symbol(),MODE_TICKVALUE);
         double newSL=0;
         if(type==OP_BUY){ newSL=Bid-tsPoints*Point; if(curSL<newSL) OrderModify(OrderTicket(),entry,newSL,OrderTakeProfit(),0,clrYellow);}
         if(type==OP_SELL){ newSL=Ask+tsPoints*Point; if(curSL==0 || curSL>newSL) OrderModify(OrderTicket(),entry,newSL,OrderTakeProfit(),0,clrYellow);}
      }
   }
#else
   int total=PositionsTotal();
   for(int i=0;i<total;i++)
   {
      if(PositionSelectByIndex(i))
      {
         string sym=PositionGetString(POSITION_SYMBOL);
         if(sym!=_Symbol) continue;
         int type=(int)PositionGetInteger(POSITION_TYPE);
         double entry=PositionGetDouble(POSITION_PRICE_OPEN);
         double curSL=PositionGetDouble(POSITION_SL);
         double lots=PositionGetDouble(POSITION_VOLUME);
         double tsPoints=(AccountEquity()*TrailingStopPercent/100)/SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
         double newSL=0;
         if(type==POSITION_TYPE_BUY) { newSL=SymbolInfoDouble(_Symbol,SYMBOL_BID)-tsPoints; if(curSL<newSL) trade.PositionModify(_Symbol,newSL,0);}
         if(type==POSITION_TYPE_SELL){ newSL=SymbolInfoDouble(_Symbol,SYMBOL_ASK)+tsPoints; if(curSL==0 || curSL>newSL) trade.PositionModify(_Symbol,newSL,0);}
      }
   }
#endif
}

//+------------------------------------------------------------------+
// Main OnTick
void OnTick()
{
   if(TimeDay(TimeCurrent())!=TimeDay(lastTradeDay) || startOfDayBalance==0) ResetDailyStats();

   datetime now=TimeCurrent();
   int brokerHour=TimeHour(now);
   int brokerMinute=TimeMinute(now);
   int estHour=brokerHour-(GmtOffset+5); if(estHour<0) estHour+=24;

   if(estHour>=EndHourEST && !closedAtNoon)
   {
      CloseAllTrades("End of trading window");
      closedAtNoon=true;
   }

   double drawdown=(startOfDayBalance-AccountBalance())/startOfDayBalance;
   if(drawdown>=MaxDailyLoss)
   {
      if(!tradingLocked){ Print("Daily loss limit reached. Trading locked."); tradingLocked=true; }
      CloseAllTrades("Daily drawdown limit");
      return;
   }

   if(tradingLocked || !InTradingWindow()) return;
   if(Bars<BarsPerPattern+LookAheadBars+10) return;

   ApplyTrailingStops();

   // --- Pattern match
   double currPattern[]; ArrayResize(currPattern,BarsPerPattern);
   for(int i=0;i<BarsPerPattern;i++) currPattern[i]=Close[i];
   double cMin=ArrayMinimum(currPattern,0,BarsPerPattern);
   double cMax=ArrayMaximum(currPattern,0,BarsPerPattern);
   double cScale=cMax-cMin; if(cScale==0) return;
   for(int i=0;i<BarsPerPattern;i++) currPattern[i]=(currPattern[i]-cMin)/cScale;

   double bestMatch=0; int bestIndex=-1;
   int limit=MathMin(Bars-BarsPerPattern-LookAheadBars,HistoryLimit);
   for(int shift=BarsPerPattern+LookAheadBars; shift<limit; shift+=Step)
   {
      double histPattern[]; ArrayResize(histPattern,BarsPerPattern);
      for(int j=0;j<BarsPerPattern;j++) histPattern[j]=Close[shift+j];
      double hMin=ArrayMinimum(histPattern,0,BarsPerPattern);
      double hMax=ArrayMaximum(histPattern,0,BarsPerPattern);
      double hScale=hMax-hMin; if(hScale==0) continue;
      for(int j=0;j<BarsPerPattern;j++) histPattern[j]=(histPattern[j]-hMin)/hScale;
      double sim=PatternSimilarity(currPattern,histPattern,BarsPerPattern);
      if(sim>bestMatch){ bestMatch=sim; bestIndex=shift; }
   }

   if(bestIndex<0 || bestMatch<SimilarityThreshold) return;

   double endPrice=Close[bestIndex+BarsPerPattern+LookAheadBars];
   double startPrice=Close[bestIndex+BarsPerPattern];
   int patternDir=(endPrice>startPrice)?1:-1;

   DrawPatternVisualization(patternDir);

   // --- MA confirmation
   double maValue=iMA(Symbol(),0,MA_Period,0,MA_Method,MA_AppliedPrice,0);
   int maDir=(Close[0]>maValue)?1:-1;

   // --- RSI confirmation
   double rsi=iRSI(Symbol(),0,RSI_Period,PRICE_CLOSE,0);
   int rsiDir=0; if(rsi>RSI_BuyLevel) rsiDir=1; else if(rsi<RSI_SellLevel) rsiDir=-1;
   if(rsiDir==0 || patternDir!=maDir || patternDir!=rsiDir) return;

   // --- Trade sizing
   double equity=AccountEquity();
   double slPoints=(equity*RiskPerTrade/MarketInfo(Symbol(),MODE_TICKVALUE))/Point;
   double tpPoints=slPoints*RiskRewardRatio;
   double lotSize=NormalizeDouble(RiskPerTrade*equity/slPoints/MarketInfo(Symbol(),MODE_TICKVALUE),2);

#ifdef __MQL4__
   int ticket=-1;
   if(patternDir==1) ticket=OrderSend(Symbol(),OP_BUY,lotSize,Ask,2,Ask-slPoints*Point,Ask+tpPoints*Point,"PatternBuy",0,0,clrLime);
   else if(patternDir==-1) ticket=OrderSend(Symbol(),OP_SELL,lotSize,Bid,2,Bid+slPoints*Point,Bid-tpPoints*Point,"PatternSell",0,0,clrRed);
   if(ticket>0){ double entry=(patternDir==1)?Ask:Bid; LogTrade("Triple confirmation",patternDir==1?0:1,lotSize,entry,0,0); }
#else
   if(patternDir==1){ trade.Buy(lotSize,NULL,0,0,0,"PatternBuy"); LogTrade("Triple confirmation",0,lotSize,SymbolInfoDouble(_Symbol,SYMBOL_ASK),0,0);}
   else if(patternDir==-1){ trade.Sell(lotSize,NULL,0,0,0,"PatternSell"); LogTrade("Triple confirmation",1,lotSize,SymbolInfoDouble(_Symbol,SYMBOL_BID),0,0);}
#endif
}
